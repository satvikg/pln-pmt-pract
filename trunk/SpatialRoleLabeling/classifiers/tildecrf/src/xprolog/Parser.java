package xprolog;

/* Generated By:JavaCC: Do not edit this line. Parser.java */
import java.io.StringReader;
import java.util.Hashtable;
import java.util.Vector;

public class Parser implements ParserConstants {

    public static void main(String args[]) throws ParseException {
        KnowledgeBase kb = new KnowledgeBase();
        Parser parser = new Parser(new StringReader(

        "eq(X,X).   X=X.  fail :- eq(c,d). true. " + "print(X) := 1." + "nl         := 2."
                + "assert(X)  := 3." +

                "or(X,Y) :- call(X). or(X,Y) :- call(Y)."));

        parser.primitives(kb);
        kb.dump(true);
    }

    public// static
    TermList getList(String query) throws ParseException {
        resetVDict();
        ReInit(new StringReader(query));
        return goals();
    }

    public// static
    Term getTerm(String query) throws ParseException {
        ReInit(new StringReader(query));
        resetVDict();
        return goal();
    }

    // static Hashtable vardict;
    // static int varnum;
    Hashtable vardict;

    int varnum;

    public static int maxVarnum = 0;

    public// static
    void resetVDict() {
        vardict = new Hashtable();
        varnum = 0;
    }

    final public void Program(KnowledgeBase kb) throws ParseException {
        label_1: while (true) {
            clause(kb);
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CHAR_LITERAL:
            case ATOM:
                ;
                break;
            default:
                jj_la1[0] = jj_gen;
                break label_1;
            }
        }
        jj_consume_token(0);
    }

    final public void clause(KnowledgeBase kb) throws ParseException {
        Term head;
        TermList body = null;
        Clause c;
        resetVDict();
        head = pred();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case 19:
            jj_consume_token(19);
            body = goals();
            break;
        default:
            jj_la1[1] = jj_gen;
            ;
        }
        jj_consume_token(20);
        c = new Clause(head, body);
        kb.addClause(c);
        // System.out.println("Clause: " + c);

    }

    final public void primitives(KnowledgeBase kb) throws ParseException {
        label_2: while (true) {
            primitive(kb);
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CUT:
            case NUMBER:
            case CHAR_LITERAL:
            case VAR:
            case ATOM:
            case 23:
            case 27:
                ;
                break;
            default:
                jj_la1[2] = jj_gen;
                break label_2;
            }
        }
        jj_consume_token(0);
    }

    final public void primitive(KnowledgeBase kb) throws ParseException {
        Term head;
        Token tok = null;
        boolean opt = true;
        TermList body = null;
        resetVDict();
        head = goal();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case 19:
        case 21:
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case 21:
                jj_consume_token(21);
                tok = jj_consume_token(NUMBER);
                kb.addPrimitive(new Clause(head, new Primitive(tok.image)));
                opt = false;
                break;
            case 19:
                jj_consume_token(19);
                body = goals();
                kb.addPrimitive(new Clause(head, body));
                opt = false;
                break;
            default:
                jj_la1[3] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
            break;
        default:
            jj_la1[4] = jj_gen;
            ;
        }
        jj_consume_token(20);
        if (opt)
            kb.addPrimitive(new Clause(head, null));
    }

    final public TermList goals() throws ParseException {
        Term t;
        TermList head, last, p;
        t = goal();
        head = last = new TermList(t);
        label_3: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case 22:
                ;
                break;
            default:
                jj_la1[5] = jj_gen;
                break label_3;
            }
            jj_consume_token(22);
            t = goal();
            last.next = p = new TermList(t);
            last = p;
        }
        {
            if (true)
                return head;
        }
        throw new Error("Missing return statement in function");
    }

    final public Term pred() throws ParseException {
        Token op;
        Vector v = new Vector();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case ATOM:
            op = jj_consume_token(ATOM);
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case 23:
                jj_consume_token(23);
                arglist(v);
                jj_consume_token(24);
                break;
            default:
                jj_la1[6] = jj_gen;
                ;
            }
            int arity = v.size();
            Term terms[] = new Term[arity];
            for (int i = 0; i < arity; i++)
                terms[i] = (Term) v.elementAt(i);
            {
                if (true)
                    return new Term(op.image.intern(), terms);
            }
            break;
        case CHAR_LITERAL:
            op = jj_consume_token(CHAR_LITERAL);
            String s = op.image;
            {
                if (true)
                    return new Term(s.substring(1, s.length() - 1).intern(), 0);
            }
            break;
        default:
            jj_la1[7] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    final public void arglist(Vector v) throws ParseException {
        Term t;
        t = arg();
        v.addElement(t);
        label_4: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case 22:
                ;
                break;
            default:
                jj_la1[8] = jj_gen;
                break label_4;
            }
            jj_consume_token(22);
            t = arg();
            v.addElement(t);
        }
    }

    // --------------------------------------
    final public Term goal() throws ParseException {
        Term x;
        Term s1 = null, s2 = null, s3 = null;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case 23:
            jj_consume_token(23);
            s1 = goal_list();
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case 25:
                jj_consume_token(25);
                s2 = goal_list();
                break;
            default:
                jj_la1[9] = jj_gen;
                ;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case 26:
                jj_consume_token(26);
                s3 = goal_list();
                break;
            default:
                jj_la1[10] = jj_gen;
                ;
            }
            jj_consume_token(24);
            if (s2 == null && s3 == null) {
                x = new Term("seq", 1);
                x.setarg(0, s1);
                {
                    if (true)
                        return x;
                }
            } else if (s2 == null) {
                if (true)
                    return new Term("or", s1, s3);
            } else if (s3 == null) {
                if (true)
                    return new Term("if", s1, s2);
            } else {
                Term ts[] = new Term[3];
                ts[0] = s1;
                ts[1] = s2;
                ts[2] = s3;
                {
                    if (true)
                        return new Term("if", ts);
                }
            }
            break;
        case NUMBER:
        case CHAR_LITERAL:
        case VAR:
        case ATOM:
        case 27:
            x = arg();
            // System.out.println(" Goal: " + x );
            {
                if (true)
                    return x;
            }
            break;
        case CUT:
            jj_consume_token(CUT);
            {
                if (true)
                    return Term.CUT;
            }
            break;
        default:
            jj_la1[11] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    // ------------------------
    final public Term goal_list() throws ParseException {
        Vector v = new Vector();
        Term t;
        t = goal();
        v.addElement(t);
        label_5: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case 22:
                ;
                break;
            default:
                jj_la1[12] = jj_gen;
                break label_5;
            }
            jj_consume_token(22);
            t = goal();
            v.addElement(t);
        }
        int j = v.size();
        t = new Term("null", 0);
        ;
        while (--j >= 0)
            t = new Term("cons", (Term) v.elementAt(j), t);
        {
            if (true)
                return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Term arg() throws ParseException {
        Term t1, t2;
        Token op;
        t1 = sum();
        label_6: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case RELOP:
                ;
                break;
            default:
                jj_la1[13] = jj_gen;
                break label_6;
            }
            op = jj_consume_token(RELOP);
            t2 = sum();
            t1 = new Term(op.image.intern(), t1, t2);
        }
        {
            if (true)
                return t1;
        }
        throw new Error("Missing return statement in function");
    }

    final public Term sum() throws ParseException {
        Term t1, t2;
        Token op;
        t1 = factor();
        label_7: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ADDOP:
                ;
                break;
            default:
                jj_la1[14] = jj_gen;
                break label_7;
            }
            op = jj_consume_token(ADDOP);
            t2 = factor();
            t1 = new Term(op.image.intern(), t1, t2);
        }
        {
            if (true)
                return t1;
        }
        throw new Error("Missing return statement in function");
    }

    final public Term factor() throws ParseException {
        Term t1, t2;
        Token op;
        t1 = operand();
        label_8: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case MULOP:
                ;
                break;
            default:
                jj_la1[15] = jj_gen;
                break label_8;
            }
            op = jj_consume_token(MULOP);
            t2 = operand();
            t1 = new Term(op.image.intern(), t1, t2);
        }
        {
            if (true)
                return t1;
        }
        throw new Error("Missing return statement in function");
    }

    final public Term operand() throws ParseException {
        Token tok;
        Term t;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case CHAR_LITERAL:
        case ATOM:
            t = pred();
            {
                if (true)
                    return t;
            }
            break;
        case VAR:
            tok = jj_consume_token(VAR);
            String s = tok.image;
            t = (Term) vardict.get(s);
            if (t == null) {
                t = new Term(varnum++);
                if (varnum > maxVarnum)
                    maxVarnum = varnum;
                if (!s.equals("_"))
                    vardict.put(s, t);
            }
            {
                if (true)
                    return t;
            }
            break;
        case NUMBER:
            tok = jj_consume_token(NUMBER);
            {
                if (true)
                    return new Number(tok.image.intern());
            }
            break;
        case 27:
            t = list();
            {
                if (true)
                    return t;
            }
            break;
        default:
            jj_la1[16] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    final public Term list() throws ParseException {
        Vector v = new Vector();
        jj_consume_token(27);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case NUMBER:
        case CHAR_LITERAL:
        case VAR:
        case ATOM:
        case 27:
            listElems(v);
            break;
        default:
            jj_la1[17] = jj_gen;
            ;
        }
        jj_consume_token(28);
        if (v.size() == 0) {
            if (true)
                return new Term("null", 0);
        } else {
            int j = v.size() - 1;
            Term t = (Term) v.elementAt(j);
            while (--j >= 0)
                t = new Term("cons", (Term) v.elementAt(j), t);
            {
                if (true)
                    return t;
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public void listElems(Vector v) throws ParseException {
        Term t = null;
        arglist(v);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case 29:
            jj_consume_token(29);
            t = arg();
            break;
        default:
            jj_la1[18] = jj_gen;
            ;
        }
        if (t == null)
            v.addElement(new Term("null", 0));
        else
            v.addElement(t);
    }

    public ParserTokenManager token_source;

    SimpleCharStream jj_input_stream;

    public Token token, jj_nt;

    private int jj_ntk;

    private int jj_gen;

    final private int[] jj_la1 = new int[19];

    final private int[] jj_la1_0 = { 0xa000, 0x80000, 0x880e880, 0x280000, 0x280000, 0x400000, 0x800000,
            0xa000, 0x400000, 0x2000000, 0x4000000, 0x880e880, 0x400000, 0x400, 0x100, 0x200, 0x800e800,
            0x800e800, 0x20000000, };

    public Parser(java.io.InputStream stream) {
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new ParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 19; i++)
            jj_la1[i] = -1;
    }

    public void ReInit(java.io.InputStream stream) {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 19; i++)
            jj_la1[i] = -1;
    }

    public Parser(java.io.Reader stream) {
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new ParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 19; i++)
            jj_la1[i] = -1;
    }

    public void ReInit(java.io.Reader stream) {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 19; i++)
            jj_la1[i] = -1;
    }

    public Parser(ParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 19; i++)
            jj_la1[i] = -1;
    }

    public void ReInit(ParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 19; i++)
            jj_la1[i] = -1;
    }

    final private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null)
            token = token.next;
        else
            token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    final public Token getNextToken() {
        if (token.next != null)
            token = token.next;
        else
            token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    final public Token getToken(int index) {
        Token t = token;
        for (int i = 0; i < index; i++) {
            if (t.next != null)
                t = t.next;
            else
                t = t.next = token_source.getNextToken();
        }
        return t;
    }

    final private int jj_ntk() {
        if ((jj_nt = token.next) == null)
            return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        else
            return (jj_ntk = jj_nt.kind);
    }

    private java.util.Vector jj_expentries = new java.util.Vector();

    private int[] jj_expentry;

    private int jj_kind = -1;

    final public ParseException generateParseException() {
        jj_expentries.removeAllElements();
        boolean[] la1tokens = new boolean[30];
        for (int i = 0; i < 30; i++) {
            la1tokens[i] = false;
        }
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 19; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 30; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.addElement(jj_expentry);
            }
        }
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = (int[]) jj_expentries.elementAt(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    final public void enable_tracing() {}

    final public void disable_tracing() {}

}
